From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Apehum <apehumchik@gmail.com>
Date: Thu, 9 Dec 2021 02:18:17 +0800
Subject: [PATCH] Feature Secure Seed


diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 7780c6cd92a716e62625df95841680b0e99a86e6..a85a08cb3c553945333af74d00b2cc9cc0964bad 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -49,6 +49,8 @@ import net.minecraft.world.level.storage.LevelStorageSource;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper
+import su.plo.matter.Globals;
+
 import java.util.function.Function; // Paper
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
 
@@ -1148,6 +1150,8 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public ChunkGenerator getGenerator() {
+        // Matter
+        Globals.setupGlobals(level);
         return this.chunkMap.generator();
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/monster/Slime.java b/src/main/java/net/minecraft/world/entity/monster/Slime.java
index d8a21a982b4ebb133f6208fded11ba5f588d9f1f..c809a1e0a27098af9aa04a7b4d1b8b61abcd13af 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Slime.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Slime.java
@@ -419,7 +419,7 @@ public class Slime extends Mob implements Enemy {
             }
 
             ChunkPos chunkcoordintpair = new ChunkPos(pos);
-            boolean flag = world.getMinecraftWorld().paperConfig.allChunksAreSlimeChunks || WorldgenRandom.seedSlimeChunk(chunkcoordintpair.x, chunkcoordintpair.z, ((WorldGenLevel) world).getSeed(), world.getMinecraftWorld().spigotConfig.slimeSeed).nextInt(10) == 0; // Spigot // Paper
+            boolean flag = world.getMinecraftWorld().paperConfig.allChunksAreSlimeChunks || world.getChunk(chunkcoordintpair.x, chunkcoordintpair.z).isSlimeChunk(); // Spigot // Paper // Matter
 
             // Paper start - Replace rules for Height in Slime Chunks
             final double maxHeightSlimeChunk = world.getMinecraftWorld().paperConfig.slimeMaxSpawnHeightInSlimeChunks;
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
index 5aeaaae6f15050a2da271fe196d0a234ecafc8a1..ea720517a1adfb164d540c2743aaec2a058d13b8 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
@@ -36,12 +36,7 @@ import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.gameevent.GameEventDispatcher;
-import net.minecraft.world.level.levelgen.Aquifer;
-import net.minecraft.world.level.levelgen.BelowZeroRetrogen;
-import net.minecraft.world.level.levelgen.Heightmap;
-import net.minecraft.world.level.levelgen.NoiseChunk;
-import net.minecraft.world.level.levelgen.NoiseGeneratorSettings;
-import net.minecraft.world.level.levelgen.NoiseSampler;
+import net.minecraft.world.level.levelgen.*;
 import net.minecraft.world.level.levelgen.blending.Blender;
 import net.minecraft.world.level.levelgen.blending.BlendingData;
 import net.minecraft.world.level.levelgen.feature.StructureFeature;
@@ -51,6 +46,7 @@ import net.minecraft.world.ticks.SerializableTickContainer;
 import net.minecraft.world.ticks.TickContainerAccess;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import su.plo.matter.WorldgenCryptoRandom;
 
 public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiomeSource, FeatureAccess {
 
@@ -77,6 +73,11 @@ public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiom
     protected final LevelHeightAccessor levelHeightAccessor;
     protected final LevelChunkSection[] sections;
 
+    // Matter start
+    private boolean slimeChunk;
+    private boolean hasComputedSlimeChunk;
+    // Matter end
+
     // CraftBukkit start - SPIGOT-6814: move to IChunkAccess to account for 1.17 to 1.18 chunk upgrading.
     private static final org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry();
     public org.bukkit.craftbukkit.persistence.DirtyCraftPersistentDataContainer persistentDataContainer = new org.bukkit.craftbukkit.persistence.DirtyCraftPersistentDataContainer(ChunkAccess.DATA_TYPE_REGISTRY);
@@ -147,6 +148,17 @@ public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiom
     public final Registry<Biome> biomeRegistry;
     // CraftBukkit end
 
+    // Matter start
+    public boolean isSlimeChunk() {
+        if (!hasComputedSlimeChunk) {
+            hasComputedSlimeChunk = true;
+            slimeChunk = WorldgenCryptoRandom.seedSlimeChunk(chunkPos.x, chunkPos.z).nextInt(10) == 0;
+        }
+
+        return slimeChunk;
+    }
+    // Matter end
+
     private static void replaceMissingSections(LevelHeightAccessor world, Registry<Biome> biome, LevelChunkSection[] sectionArray) {
         for (int i = 0; i < sectionArray.length; ++i) {
             if (sectionArray[i] == null) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java b/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
index 0009af6e9c6a48a63736ada2653665f74ac396ca..c018017b99122885cc7eeb235a0d2a2300671991 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
@@ -68,6 +68,8 @@ import net.minecraft.world.level.levelgen.placement.PlacedFeature;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
 import net.minecraft.world.level.levelgen.structure.StructureStart;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureManager;
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
 
 public abstract class ChunkGenerator implements BiomeManager.NoiseBiomeSource {
 
@@ -109,9 +111,9 @@ public abstract class ChunkGenerator implements BiomeManager.NoiseBiomeSource {
                 int i = structuresettingsstronghold.distance();
                 int j = structuresettingsstronghold.count();
                 int k = structuresettingsstronghold.spread();
-                Random random = new Random();
+                // Matter
+                Random random = new WorldgenCryptoRandom(0, 0, Globals.Salt.STRONGHOLDS, 0);
 
-                random.setSeed(this.strongholdSeed);
                 double d0 = random.nextDouble() * 3.141592653589793D * 2.0D;
                 int l = 0;
                 int i1 = 0;
@@ -250,8 +252,12 @@ public abstract class ChunkGenerator implements BiomeManager.NoiseBiomeSource {
                 return structuregenerator.step().ordinal();
             }));
             List<BiomeSource.StepFeatureData> list = this.biomeSource.featuresPerStep();
-            WorldgenRandom seededrandom = new WorldgenRandom(new XoroshiroRandomSource(RandomSupport.seedUniquifier()));
+            // Matter start
+            WorldgenRandom seededrandom = new WorldgenCryptoRandom(
+                    blockposition.getX(), blockposition.getZ(), Globals.Salt.UNDEFINED, 0
+            );
             long i = seededrandom.setDecorationSeed(generatoraccessseed.getSeed(), blockposition.getX(), blockposition.getZ());
+            // Matter end
             Set<Biome> set = new ObjectArraySet();
 
             if (this instanceof FlatLevelSource) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java b/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
index 6c72854aa975800bd6160d104936a5ba978f4d67..92730e36dd413b40b2d448601b59ff4f5f07641f 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
@@ -26,6 +26,7 @@ import net.minecraft.world.level.levelgen.GenerationStep;
 import net.minecraft.world.level.levelgen.Heightmap;
 import net.minecraft.world.level.levelgen.blending.Blender;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureManager;
+import su.plo.matter.Globals;
 
 public class ChunkStatus {
 
@@ -268,6 +269,8 @@ public class ChunkStatus {
     }
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> generate(Executor executor, ServerLevel world, ChunkGenerator generator, StructureManager structureManager, ThreadedLevelLightEngine lightingProvider, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> fullChunkConverter, List<ChunkAccess> chunks, boolean flag) {
+        // Matter
+        Globals.setupGlobals(world);
         ChunkAccess ichunkaccess = (ChunkAccess) chunks.get(chunks.size() / 2);
         ProfiledDuration profiledduration = JvmProfiler.INSTANCE.onChunkGenerate(ichunkaccess.getPos(), world.dimension(), this.name);
         CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.generationTask.doWork(this, executor, world, generator, structureManager, lightingProvider, fullChunkConverter, chunks, ichunkaccess, flag);
diff --git a/src/main/java/net/minecraft/world/level/levelgen/WorldGenSettings.java b/src/main/java/net/minecraft/world/level/levelgen/WorldGenSettings.java
index 286c75989282c6d370ca64ac714ab15d784210ab..085b498cd764e853f303f95155aaefe2203d85d7 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/WorldGenSettings.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/WorldGenSettings.java
@@ -20,6 +20,8 @@ import java.util.Properties;
 import java.util.Random;
 import java.util.function.Function;
 import java.util.function.Supplier;
+import java.util.stream.LongStream;
+
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.server.packs.resources.ResourceManager;
 import net.minecraft.util.GsonHelper;
@@ -37,16 +39,21 @@ import net.minecraft.core.Registry;
 import net.minecraft.core.RegistryAccess;
 // CraftBukkit start
 import net.minecraft.resources.RegistryReadOps;
+import su.plo.matter.Globals;
 
 public class WorldGenSettings {
-
     public static final Codec<WorldGenSettings> CODEC = RecordCodecBuilder.<WorldGenSettings>create((instance) -> { // CraftBukkit - decompile error
-        return instance.group(Codec.LONG.fieldOf("seed").stable().forGetter(WorldGenSettings::seed), Codec.BOOL.fieldOf("generate_features").orElse(true).stable().forGetter(WorldGenSettings::generateFeatures), Codec.BOOL.fieldOf("bonus_chest").orElse(false).stable().forGetter(WorldGenSettings::generateBonusChest), MappedRegistry.dataPackCodec(Registry.LEVEL_STEM_REGISTRY, Lifecycle.stable(), LevelStem.CODEC).xmap(LevelStem::sortMap, Function.identity()).fieldOf("dimensions").forGetter(WorldGenSettings::dimensions), Codec.STRING.optionalFieldOf("legacy_custom_options").stable().forGetter((generatorsettings) -> {
+        return instance.group(Codec.LONG.fieldOf("seed").stable().forGetter(WorldGenSettings::seed),
+                Codec.LONG_STREAM.fieldOf("feature_seed").stable().forGetter((settings) -> LongStream.of(settings.featureSeed())), // Matter
+                Codec.BOOL.fieldOf("generate_features").orElse(true).stable().forGetter(WorldGenSettings::generateFeatures),
+                Codec.BOOL.fieldOf("bonus_chest").orElse(false).stable().forGetter(WorldGenSettings::generateBonusChest), MappedRegistry.dataPackCodec(Registry.LEVEL_STEM_REGISTRY, Lifecycle.stable(), LevelStem.CODEC).xmap(LevelStem::sortMap, Function.identity()).fieldOf("dimensions").forGetter(WorldGenSettings::dimensions), Codec.STRING.optionalFieldOf("legacy_custom_options").stable().forGetter((generatorsettings) -> {
             return generatorsettings.legacyCustomOptions;
         })).apply(instance, instance.stable(WorldGenSettings::new));
     }).comapFlatMap(WorldGenSettings::guardExperimental, Function.identity());
     private static final Logger LOGGER = LogManager.getLogger();
     private final long seed;
+    // Matter
+    private final long[] featureSeed;
     private final boolean generateFeatures;
     private final boolean generateBonusChest;
     private final MappedRegistry<LevelStem> dimensions;
@@ -62,8 +69,13 @@ public class WorldGenSettings {
         return LevelStem.stable(this.seed, this.dimensions);
     }
 
-    public WorldGenSettings(long seed, boolean generateStructures, boolean bonusChest, MappedRegistry<LevelStem> options) {
-        this(seed, generateStructures, bonusChest, options, Optional.empty());
+    // Matter start
+    public WorldGenSettings(long seed, LongStream featureSeed, boolean generateStructures, boolean bonusChest, MappedRegistry<LevelStem> options) {
+        this(seed, featureSeed.toArray(), generateStructures, bonusChest, options);
+    }
+
+    public WorldGenSettings(long seed, long[] featureSeed, boolean generateStructures, boolean bonusChest, MappedRegistry<LevelStem> options) {
+        this(seed, featureSeed, generateStructures, bonusChest, options, Optional.empty());
         LevelStem worlddimension = (LevelStem) options.get(LevelStem.OVERWORLD);
 
         if (worlddimension == null) {
@@ -71,24 +83,32 @@ public class WorldGenSettings {
         }
     }
 
-    private WorldGenSettings(long seed, boolean generateStructures, boolean bonusChest, MappedRegistry<LevelStem> options, Optional<String> legacyCustomOptions) {
+    public WorldGenSettings(long seed, LongStream featureSeed, boolean generateStructures, boolean bonusChest, MappedRegistry<LevelStem> options, Optional<String> legacyCustomOptions) {
+        this(seed, featureSeed.toArray(), generateStructures, bonusChest, options, legacyCustomOptions);
+    }
+
+    private WorldGenSettings(long seed, long[] featureSeed, boolean generateStructures, boolean bonusChest, MappedRegistry<LevelStem> options, Optional<String> legacyCustomOptions) {
         this.seed = seed;
+        this.featureSeed = featureSeed;
         this.generateFeatures = generateStructures;
         this.generateBonusChest = bonusChest;
         this.dimensions = options;
         this.legacyCustomOptions = legacyCustomOptions;
     }
+    // Matter end
 
     public static WorldGenSettings demoSettings(RegistryAccess registryManager) {
         int i = "North Carolina".hashCode();
 
-        return new WorldGenSettings((long) i, true, true, WorldGenSettings.withOverworld(registryManager.registryOrThrow(Registry.DIMENSION_TYPE_REGISTRY), DimensionType.defaultDimensions(registryManager, (long) i), WorldGenSettings.makeDefaultOverworld(registryManager, (long) i)));
+        // Matter
+        return new WorldGenSettings((long) i, Globals.parseSeed("North Carolina"), true, true, WorldGenSettings.withOverworld(registryManager.registryOrThrow(Registry.DIMENSION_TYPE_REGISTRY), DimensionType.defaultDimensions(registryManager, (long) i), WorldGenSettings.makeDefaultOverworld(registryManager, (long) i)));
     }
 
     public static WorldGenSettings makeDefault(RegistryAccess registryManager) {
         long i = (new Random()).nextLong();
 
-        return new WorldGenSettings(i, true, false, WorldGenSettings.withOverworld(registryManager.registryOrThrow(Registry.DIMENSION_TYPE_REGISTRY), DimensionType.defaultDimensions(registryManager, i), WorldGenSettings.makeDefaultOverworld(registryManager, i)));
+        // Matter
+        return new WorldGenSettings(i, Globals.createRandomWorldSeed(), true, false, WorldGenSettings.withOverworld(registryManager.registryOrThrow(Registry.DIMENSION_TYPE_REGISTRY), DimensionType.defaultDimensions(registryManager, i), WorldGenSettings.makeDefaultOverworld(registryManager, i)));
     }
 
     public static NoiseBasedChunkGenerator makeDefaultOverworld(RegistryAccess registryManager, long seed) {
@@ -113,6 +133,12 @@ public class WorldGenSettings {
         return this.seed;
     }
 
+    // Matter start
+    public long[] featureSeed() {
+        return this.featureSeed;
+    }
+    // Matter end
+
     public boolean generateFeatures() {
         return this.generateFeatures;
     }
@@ -187,24 +213,32 @@ public class WorldGenSettings {
     }
 
     public WorldGenSettings withBonusChest() {
-        return new WorldGenSettings(this.seed, this.generateFeatures, true, this.dimensions, this.legacyCustomOptions);
+        // Matter
+        return new WorldGenSettings(this.seed, this.featureSeed, this.generateFeatures, true, this.dimensions, this.legacyCustomOptions);
     }
 
     public WorldGenSettings withFeaturesToggled() {
-        return new WorldGenSettings(this.seed, !this.generateFeatures, this.generateBonusChest, this.dimensions);
+        // Matter
+        return new WorldGenSettings(this.seed, this.featureSeed, !this.generateFeatures, this.generateBonusChest, this.dimensions);
     }
 
     public WorldGenSettings withBonusChestToggled() {
-        return new WorldGenSettings(this.seed, this.generateFeatures, !this.generateBonusChest, this.dimensions);
+        // Matter
+        return new WorldGenSettings(this.seed, this.featureSeed, this.generateFeatures, !this.generateBonusChest, this.dimensions);
     }
 
     public static WorldGenSettings create(RegistryAccess registryManager, Properties properties) {
         String s = (String) MoreObjects.firstNonNull((String) properties.get("generator-settings"), "");
 
         properties.put("generator-settings", s);
+        // Matter start
         String s1 = (String) MoreObjects.firstNonNull((String) properties.get("level-seed"), "");
-
         properties.put("level-seed", s1);
+
+        String featureSeedString = (String) MoreObjects.firstNonNull((String) properties.get("feature-level-seed"), "");
+        properties.put("feature-level-seed", featureSeedString);
+        // Matter end
+
         String s2 = (String) properties.get("generate-structures");
         boolean flag = s2 == null || Boolean.parseBoolean(s2);
 
@@ -229,6 +263,19 @@ public class WorldGenSettings {
             }
         }
 
+        // Matter start
+        long[] featureSeed;
+        if (!featureSeedString.isEmpty()) {
+            try {
+                featureSeed = Globals.parseSeed(featureSeedString);
+            } catch (NumberFormatException e) {
+                featureSeed = Globals.createRandomWorldSeed();
+            }
+        } else {
+            featureSeed = Globals.createRandomWorldSeed();
+        }
+        // Matter end
+
         Registry<DimensionType> iregistry = registryManager.registryOrThrow(Registry.DIMENSION_TYPE_REGISTRY);
         Registry<Biome> iregistry1 = registryManager.registryOrThrow(Registry.BIOME_REGISTRY);
         MappedRegistry<LevelStem> registrymaterials = DimensionType.defaultDimensions(registryManager, i);
@@ -264,22 +311,29 @@ public class WorldGenSettings {
                 Logger logger = WorldGenSettings.LOGGER;
 
                 Objects.requireNonNull(logger);
-                return new WorldGenSettings(i, flag, false, WorldGenSettings.withOverworld(iregistry, registrymaterials, new FlatLevelSource((FlatLevelGeneratorSettings) dataresult.resultOrPartial(logger::error).orElseGet(() -> {
+                // Matter
+                return new WorldGenSettings(i, featureSeed, flag, false, WorldGenSettings.withOverworld(iregistry, registrymaterials, new FlatLevelSource((FlatLevelGeneratorSettings) dataresult.resultOrPartial(logger::error).orElseGet(() -> {
                     return FlatLevelGeneratorSettings.getDefault(iregistry1);
                 }))));
             case 1:
-                return new WorldGenSettings(i, flag, false, WorldGenSettings.withOverworld(iregistry, registrymaterials, new DebugLevelSource(iregistry1)));
+                // Matter
+                return new WorldGenSettings(i, featureSeed, flag, false, WorldGenSettings.withOverworld(iregistry, registrymaterials, new DebugLevelSource(iregistry1)));
             case 2:
-                return new WorldGenSettings(i, flag, false, WorldGenSettings.withOverworld(iregistry, registrymaterials, WorldGenSettings.makeOverworld(registryManager, i, NoiseGeneratorSettings.AMPLIFIED)));
+                // Matter
+                return new WorldGenSettings(i, featureSeed, flag, false, WorldGenSettings.withOverworld(iregistry, registrymaterials, WorldGenSettings.makeOverworld(registryManager, i, NoiseGeneratorSettings.AMPLIFIED)));
             case 3:
-                return new WorldGenSettings(i, flag, false, WorldGenSettings.withOverworld(iregistry, registrymaterials, WorldGenSettings.makeOverworld(registryManager, i, NoiseGeneratorSettings.LARGE_BIOMES)));
+                // Matter
+                return new WorldGenSettings(i, featureSeed, flag, false, WorldGenSettings.withOverworld(iregistry, registrymaterials, WorldGenSettings.makeOverworld(registryManager, i, NoiseGeneratorSettings.LARGE_BIOMES)));
             default:
-                return new WorldGenSettings(i, flag, false, WorldGenSettings.withOverworld(iregistry, registrymaterials, WorldGenSettings.makeDefaultOverworld(registryManager, i)));
+                // Matter
+                return new WorldGenSettings(i, featureSeed, flag, false, WorldGenSettings.withOverworld(iregistry, registrymaterials, WorldGenSettings.makeDefaultOverworld(registryManager, i)));
         }
     }
 
     public WorldGenSettings withSeed(boolean hardcore, OptionalLong seed) {
         long i = seed.orElse(this.seed);
+        // Matter
+        long[] featureSeed = Globals.createRandomWorldSeed();
         MappedRegistry registrymaterials;
 
         if (seed.isPresent()) {
@@ -300,9 +354,11 @@ public class WorldGenSettings {
         WorldGenSettings generatorsettings;
 
         if (this.isDebug()) {
-            generatorsettings = new WorldGenSettings(i, false, false, registrymaterials);
+            // Matter
+            generatorsettings = new WorldGenSettings(i, featureSeed, false, false, registrymaterials);
         } else {
-            generatorsettings = new WorldGenSettings(i, this.generateFeatures(), this.generateBonusChest() && !hardcore, registrymaterials);
+            // Matter
+            generatorsettings = new WorldGenSettings(i, featureSeed, this.generateFeatures(), this.generateBonusChest() && !hardcore, registrymaterials);
         }
 
         return generatorsettings;
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/BastionFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/BastionFeature.java
index 61fc0485c4896b62f74b92c3b4b93f22cbfb3ed7..c3bd1ccb83d2c5a02c265c38dee237eb902193c1 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/BastionFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/BastionFeature.java
@@ -1,10 +1,11 @@
 package net.minecraft.world.level.levelgen.feature;
 
 import com.mojang.serialization.Codec;
-import net.minecraft.world.level.levelgen.LegacyRandomSource;
 import net.minecraft.world.level.levelgen.WorldgenRandom;
 import net.minecraft.world.level.levelgen.feature.configurations.JigsawConfiguration;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGeneratorSupplier;
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
 
 public class BastionFeature extends JigsawFeature {
     private static final int BASTION_SPAWN_HEIGHT = 33;
@@ -14,8 +15,11 @@ public class BastionFeature extends JigsawFeature {
     }
 
     private static boolean checkLocation(PieceGeneratorSupplier.Context<JigsawConfiguration> context) {
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
-        worldgenRandom.setLargeFeatureSeed(context.seed(), context.chunkPos().x, context.chunkPos().z);
+        // Matter start
+        WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(
+                context.chunkPos().x, context.chunkPos().z, Globals.Salt.NETHER_FORTRESS_FEATURE, 0
+        );
+        // Matter end
         return worldgenRandom.nextInt(5) >= 2;
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/BuriedTreasureFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/BuriedTreasureFeature.java
index 54341db6faf66c8e84156ee3a310fd0d6561b632..01e44d84a8bddb98a2463028c6ea992db89b7cc8 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/BuriedTreasureFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/BuriedTreasureFeature.java
@@ -4,13 +4,14 @@ import com.mojang.serialization.Codec;
 import net.minecraft.core.BlockPos;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.levelgen.Heightmap;
-import net.minecraft.world.level.levelgen.LegacyRandomSource;
 import net.minecraft.world.level.levelgen.WorldgenRandom;
 import net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration;
 import net.minecraft.world.level.levelgen.structure.BuriedTreasurePieces;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGenerator;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGeneratorSupplier;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePiecesBuilder;
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
 
 public class BuriedTreasureFeature extends StructureFeature<ProbabilityFeatureConfiguration> {
     private static final int RANDOM_SALT = 10387320;
@@ -20,11 +21,11 @@ public class BuriedTreasureFeature extends StructureFeature<ProbabilityFeatureCo
     }
 
     private static boolean checkLocation(PieceGeneratorSupplier.Context<ProbabilityFeatureConfiguration> context) {
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
-        // Purpur start
-        int salt = org.purpurmc.purpur.PurpurConfig.seedStructureBuriedTreasure;
-        worldgenRandom.setLargeFeatureWithSalt(context.seed(), context.chunkPos().x, context.chunkPos().z, salt != -1 ? salt : RANDOM_SALT);
-        // Purpur end
+        // Matter start
+        WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(
+                context.chunkPos().x, context.chunkPos().z, Globals.Salt.BURIED_TREASURE_FEATURE, 0
+        );
+        // Matter end
         return worldgenRandom.nextFloat() < (context.config()).probability && context.validBiomeOnTop(Heightmap.Types.OCEAN_FLOOR_WG);
     }
 
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/GeodeFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/GeodeFeature.java
index 24110d4d412b5bd0a6c17215b889ea6c02558a2c..afb23e32ed7ec4f389be09afdce758b3b967f3f3 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/GeodeFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/GeodeFeature.java
@@ -24,6 +24,8 @@ import net.minecraft.world.level.levelgen.WorldgenRandom;
 import net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration;
 import net.minecraft.world.level.levelgen.synth.NormalNoise;
 import net.minecraft.world.level.material.FluidState;
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
 
 public class GeodeFeature extends Feature<GeodeConfiguration> {
     private static final Direction[] DIRECTIONS = Direction.values();
@@ -42,7 +44,8 @@ public class GeodeFeature extends Feature<GeodeConfiguration> {
         int j = geodeConfiguration.maxGenOffset;
         List<Pair<BlockPos, Integer>> list = Lists.newLinkedList();
         int k = geodeConfiguration.distributionPoints.sample(random);
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(worldGenLevel.getSeed()));
+        // Matter
+        WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(0, 0, Globals.Salt.GEODE_FEATURE, 0);
         NormalNoise normalNoise = NormalNoise.create(worldgenRandom, -4, 1.0D);
         List<BlockPos> list2 = Lists.newLinkedList();
         double d = (double)k / (double)geodeConfiguration.outerWallDistance.getMaxValue();
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/MineshaftFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/MineshaftFeature.java
index 354a923350cbfc76645136858e8e96285de139a1..6f9bd5820acf6185fdef57c6b446c1c4c2e8cb05 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/MineshaftFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/MineshaftFeature.java
@@ -1,9 +1,6 @@
 package net.minecraft.world.level.levelgen.feature;
 
 import com.mojang.serialization.Codec;
-import java.util.Arrays;
-import java.util.Map;
-import java.util.stream.Collectors;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.QuartPos;
 import net.minecraft.util.Mth;
@@ -12,13 +9,18 @@ import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.levelgen.Heightmap;
-import net.minecraft.world.level.levelgen.LegacyRandomSource;
 import net.minecraft.world.level.levelgen.WorldgenRandom;
 import net.minecraft.world.level.levelgen.feature.configurations.MineshaftConfiguration;
 import net.minecraft.world.level.levelgen.structure.MineShaftPieces;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGenerator;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGeneratorSupplier;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePiecesBuilder;
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
+
+import java.util.Arrays;
+import java.util.Map;
+import java.util.stream.Collectors;
 
 public class MineshaftFeature extends StructureFeature<MineshaftConfiguration> {
     public MineshaftFeature(Codec<MineshaftConfiguration> configCodec) {
@@ -26,12 +28,11 @@ public class MineshaftFeature extends StructureFeature<MineshaftConfiguration> {
     }
 
     private static boolean checkLocation(PieceGeneratorSupplier.Context<MineshaftConfiguration> context) {
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
-        // Purpur start
-        int salt = org.purpurmc.purpur.PurpurConfig.seedStructureMineshaft;
-        if (salt != -1) worldgenRandom.setLargeFeatureWithSalt(context.seed(), context.chunkPos().x, context.chunkPos().z, salt); else
-        // Purpur end
-        worldgenRandom.setLargeFeatureSeed(context.seed(), context.chunkPos().x, context.chunkPos().z);
+        // Matter start
+        WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(
+                context.chunkPos().x, context.chunkPos().z, Globals.Salt.MINESHAFT_FEATURE, 0
+        );
+        // Matter end
         double d = (double)(context.config()).probability;
         return worldgenRandom.nextDouble() >= d ? false : context.validBiome().test(context.chunkGenerator().getNoiseBiome(QuartPos.fromBlock(context.chunkPos().getMiddleBlockX()), QuartPos.fromBlock(50), QuartPos.fromBlock(context.chunkPos().getMiddleBlockZ())));
     }
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/NetherFortressFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/NetherFortressFeature.java
index c833506d8b5b046e25532823c3501e4c1cfaf52e..659ac982bac21eaed5b784f7a89351174f6b5819 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/NetherFortressFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/NetherFortressFeature.java
@@ -14,6 +14,8 @@ import net.minecraft.world.level.levelgen.structure.StructurePiece;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGenerator;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGeneratorSupplier;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePiecesBuilder;
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
 
 public class NetherFortressFeature extends StructureFeature<NoneFeatureConfiguration> {
     public static final WeightedRandomList<MobSpawnSettings.SpawnerData> FORTRESS_ENEMIES = WeightedRandomList.create(new MobSpawnSettings.SpawnerData(EntityType.BLAZE, 10, 2, 3), new MobSpawnSettings.SpawnerData(EntityType.ZOMBIFIED_PIGLIN, 5, 4, 4), new MobSpawnSettings.SpawnerData(EntityType.WITHER_SKELETON, 8, 5, 5), new MobSpawnSettings.SpawnerData(EntityType.SKELETON, 2, 5, 5), new MobSpawnSettings.SpawnerData(EntityType.MAGMA_CUBE, 3, 4, 4));
@@ -23,8 +25,11 @@ public class NetherFortressFeature extends StructureFeature<NoneFeatureConfigura
     }
 
     private static boolean checkLocation(PieceGeneratorSupplier.Context<NoneFeatureConfiguration> context) {
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
-        worldgenRandom.setLargeFeatureSeed(context.seed(), context.chunkPos().x, context.chunkPos().z);
+        // Matter start
+        WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(
+                context.chunkPos().x, context.chunkPos().z, Globals.Salt.NETHER_FORTRESS_FEATURE, 0
+        );
+        // Matter end
         return worldgenRandom.nextInt(5) >= 2 ? false : context.validBiome().test(context.chunkGenerator().getNoiseBiome(QuartPos.fromBlock(context.chunkPos().getMiddleBlockX()), QuartPos.fromBlock(64), QuartPos.fromBlock(context.chunkPos().getMiddleBlockZ())));
     }
 
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/OceanMonumentFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/OceanMonumentFeature.java
index bcfd54e917a638815813b89ab794cdc259b89cae..2b91c0baa02b8c864ff541a675c21012e0d1ecb1 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/OceanMonumentFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/OceanMonumentFeature.java
@@ -1,7 +1,6 @@
 package net.minecraft.world.level.levelgen.feature;
 
 import com.mojang.serialization.Codec;
-import java.util.Objects;
 import net.minecraft.core.Direction;
 import net.minecraft.util.random.WeightedRandomList;
 import net.minecraft.world.entity.EntityType;
@@ -9,8 +8,6 @@ import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.biome.Biome;
 import net.minecraft.world.level.biome.MobSpawnSettings;
 import net.minecraft.world.level.levelgen.Heightmap;
-import net.minecraft.world.level.levelgen.LegacyRandomSource;
-import net.minecraft.world.level.levelgen.RandomSupport;
 import net.minecraft.world.level.levelgen.WorldgenRandom;
 import net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
@@ -20,6 +17,10 @@ import net.minecraft.world.level.levelgen.structure.pieces.PieceGenerator;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGeneratorSupplier;
 import net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePiecesBuilder;
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
+
+import java.util.Objects;
 
 public class OceanMonumentFeature extends StructureFeature<NoneFeatureConfiguration> {
     public static final WeightedRandomList<MobSpawnSettings.SpawnerData> MONUMENT_ENEMIES = WeightedRandomList.create(new MobSpawnSettings.SpawnerData(EntityType.GUARDIAN, 1, 2, 4));
@@ -61,7 +62,11 @@ public class OceanMonumentFeature extends StructureFeature<NoneFeatureConfigurat
         if (pieces.isEmpty()) {
             return pieces;
         } else {
-            WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(RandomSupport.seedUniquifier()));
+            // Matter start
+            WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(
+                    pos.x, pos.z, Globals.Salt.OCEAN_MONUMENT_FEATURE, 0
+            );
+            // Matter end
             worldgenRandom.setLargeFeatureSeed(worldSeed, pos.x, pos.z);
             StructurePiece structurePiece = pieces.pieces().get(0);
             BoundingBox boundingBox = structurePiece.getBoundingBox();
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/PillagerOutpostFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/PillagerOutpostFeature.java
index 406749054596d560384db75defb18db2c1ed2ea5..37eae86ac9adc001c5c3e278ccb7b12bc99ce0a9 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/PillagerOutpostFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/PillagerOutpostFeature.java
@@ -11,6 +11,8 @@ import net.minecraft.world.level.levelgen.WorldgenRandom;
 import net.minecraft.world.level.levelgen.feature.configurations.JigsawConfiguration;
 import net.minecraft.world.level.levelgen.feature.configurations.StructureFeatureConfiguration;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGeneratorSupplier;
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
 
 public class PillagerOutpostFeature extends JigsawFeature {
     public static final WeightedRandomList<MobSpawnSettings.SpawnerData> OUTPOST_ENEMIES = WeightedRandomList.create(new MobSpawnSettings.SpawnerData(EntityType.PILLAGER, 1, 1, 1));
@@ -22,8 +24,11 @@ public class PillagerOutpostFeature extends JigsawFeature {
     private static boolean checkLocation(PieceGeneratorSupplier.Context<JigsawConfiguration> context) {
         int i = context.chunkPos().x >> 4;
         int j = context.chunkPos().z >> 4;
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
-        worldgenRandom.setSeed((long)(i ^ j << 4) ^ context.seed());
+        // Matter start
+        WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(
+                i, j, Globals.Salt.PILLAGER_OUTPOST_FEATURE, 0
+        );
+        // Matter end
         worldgenRandom.nextInt();
         if (worldgenRandom.nextInt(5) != 0) {
             return false;
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/RuinedPortalFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/RuinedPortalFeature.java
index b34750b7165ff3ec2f703d29040099f160fe6c78..8fe23e39e7d1e6113d2e19b759f29468d75a11bc 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/RuinedPortalFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/RuinedPortalFeature.java
@@ -2,12 +2,6 @@ package net.minecraft.world.level.levelgen.feature;
 
 import com.google.common.collect.ImmutableList;
 import com.mojang.serialization.Codec;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Random;
-import java.util.stream.Collectors;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.QuartPos;
@@ -22,7 +16,6 @@ import net.minecraft.world.level.block.Rotation;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.levelgen.Heightmap;
-import net.minecraft.world.level.levelgen.LegacyRandomSource;
 import net.minecraft.world.level.levelgen.WorldgenRandom;
 import net.minecraft.world.level.levelgen.feature.configurations.RuinedPortalConfiguration;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
@@ -30,6 +23,11 @@ import net.minecraft.world.level.levelgen.structure.RuinedPortalPiece;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGenerator;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGeneratorSupplier;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate;
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
+
+import java.util.*;
+import java.util.stream.Collectors;
 
 public class RuinedPortalFeature extends StructureFeature<RuinedPortalConfiguration> {
     private static final String[] STRUCTURE_LOCATION_PORTALS = new String[]{"ruined_portal/portal_1", "ruined_portal/portal_2", "ruined_portal/portal_3", "ruined_portal/portal_4", "ruined_portal/portal_5", "ruined_portal/portal_6", "ruined_portal/portal_7", "ruined_portal/portal_8", "ruined_portal/portal_9", "ruined_portal/portal_10"};
@@ -49,8 +47,11 @@ public class RuinedPortalFeature extends StructureFeature<RuinedPortalConfigurat
     private static Optional<PieceGenerator<RuinedPortalConfiguration>> pieceGeneratorSupplier(PieceGeneratorSupplier.Context<RuinedPortalConfiguration> context) {
         RuinedPortalPiece.Properties properties = new RuinedPortalPiece.Properties();
         RuinedPortalConfiguration ruinedPortalConfiguration = context.config();
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
-        worldgenRandom.setLargeFeatureSeed(context.seed(), context.chunkPos().x, context.chunkPos().z);
+        // Matter start
+        WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(
+                context.chunkPos().x, context.chunkPos().z, Globals.Salt.RUINED_PORTAL_FEATURE, 0
+        );
+        // Matter end
         RuinedPortalPiece.VerticalPlacement verticalPlacement;
         if (ruinedPortalConfiguration.portalType == RuinedPortalFeature.Type.DESERT) {
             verticalPlacement = RuinedPortalPiece.VerticalPlacement.PARTLY_BURIED;
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/StructureFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/StructureFeature.java
index 461464a4208bbb09800d87bcdb54978758863c7b..8286d7384be4914e5c0853c0ce4359948befc1de 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/StructureFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/StructureFeature.java
@@ -54,6 +54,8 @@ import net.minecraft.world.level.levelgen.structure.pieces.StructurePiecesBuilde
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureManager;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
 
 public class StructureFeature<C extends FeatureConfiguration> {
     public static final BiMap<String, StructureFeature<?>> STRUCTURES_REGISTRY = HashBiMap.create();
@@ -213,8 +215,11 @@ public class StructureFeature<C extends FeatureConfiguration> {
         int j = config.separation();
         int k = Math.floorDiv(x, i);
         int l = Math.floorDiv(z, i);
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
-        worldgenRandom.setLargeFeatureWithSalt(seed, k, l, config.salt());
+        // Matter start
+        WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(
+                k, l, Globals.Salt.POTENTIONAL_FEATURE, config.salt()
+        );
+        // Matter end
         int m;
         int n;
         if (this.linearSeparation()) {
@@ -234,8 +239,11 @@ public class StructureFeature<C extends FeatureConfiguration> {
             Optional<PieceGenerator<C>> optional = this.pieceGenerator.createGenerator(new PieceGeneratorSupplier.Context<>(chunkGenerator, biomeSource, worldSeed, pos, config, world, biomePredicate, structureManager, registryManager));
             if (optional.isPresent()) {
                 StructurePiecesBuilder structurePiecesBuilder = new StructurePiecesBuilder();
-                WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
-                worldgenRandom.setLargeFeatureSeed(worldSeed, pos.x, pos.z);
+                // Matter start
+                WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(
+                        pos.x, pos.z, Globals.Salt.GENERATE_FEATURE, 0
+                );
+                // Matter end
                 optional.get().generatePieces(structurePiecesBuilder, new PieceGenerator.Context<>(config, chunkGenerator, structureManager, pos, world, worldgenRandom, worldSeed));
                 StructureStart<C> structureStart = new StructureStart<>(this, pos, structureReferences, structurePiecesBuilder.build());
                 if (structureStart.isValid()) {
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/WoodlandMansionFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/WoodlandMansionFeature.java
index ef068df9d6ac363509ca5828e7dc8dcba4cec2a3..f0ac9c344814d3d8fc2309dfb003a9a1ab080069 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/WoodlandMansionFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/WoodlandMansionFeature.java
@@ -2,9 +2,6 @@ package net.minecraft.world.level.levelgen.feature;
 
 import com.google.common.collect.Lists;
 import com.mojang.serialization.Codec;
-import java.util.List;
-import java.util.Optional;
-import java.util.Random;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.QuartPos;
 import net.minecraft.world.level.ChunkPos;
@@ -13,7 +10,6 @@ import net.minecraft.world.level.WorldGenLevel;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.Rotation;
 import net.minecraft.world.level.chunk.ChunkGenerator;
-import net.minecraft.world.level.levelgen.LegacyRandomSource;
 import net.minecraft.world.level.levelgen.WorldgenRandom;
 import net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
@@ -21,6 +17,12 @@ import net.minecraft.world.level.levelgen.structure.WoodlandMansionPieces;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGenerator;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGeneratorSupplier;
 import net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer;
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
+
+import java.util.List;
+import java.util.Optional;
+import java.util.Random;
 
 public class WoodlandMansionFeature extends StructureFeature<NoneFeatureConfiguration> {
     public WoodlandMansionFeature(Codec<NoneFeatureConfiguration> configCodec) {
@@ -33,8 +35,11 @@ public class WoodlandMansionFeature extends StructureFeature<NoneFeatureConfigur
     }
 
     private static Optional<PieceGenerator<NoneFeatureConfiguration>> pieceGeneratorSupplier(PieceGeneratorSupplier.Context<NoneFeatureConfiguration> context) {
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
-        worldgenRandom.setLargeFeatureSeed(context.seed(), context.chunkPos().x, context.chunkPos().z);
+        // Matter start
+        WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(
+                context.chunkPos().x, context.chunkPos().z, Globals.Salt.WOODLAND_MANSION_FEATURE, 0
+        );
+        // Matter end
         Rotation rotation = Rotation.getRandom(worldgenRandom);
         int i = 5;
         int j = 5;
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/structures/JigsawPlacement.java b/src/main/java/net/minecraft/world/level/levelgen/feature/structures/JigsawPlacement.java
index ccc08dc68ebccb30995983f029c14d6e1272417b..eac69fb26451fe478002f44a187ec6014f84220a 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/structures/JigsawPlacement.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/structures/JigsawPlacement.java
@@ -2,17 +2,7 @@ package net.minecraft.world.level.levelgen.feature.structures;
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Queues;
-import java.util.Deque;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Random;
-import java.util.function.Predicate;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.Direction;
-import net.minecraft.core.QuartPos;
-import net.minecraft.core.Registry;
-import net.minecraft.core.RegistryAccess;
+import net.minecraft.core.*;
 import net.minecraft.data.worldgen.Pools;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.world.level.LevelHeightAccessor;
@@ -21,7 +11,6 @@ import net.minecraft.world.level.block.JigsawBlock;
 import net.minecraft.world.level.block.Rotation;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.levelgen.Heightmap;
-import net.minecraft.world.level.levelgen.LegacyRandomSource;
 import net.minecraft.world.level.levelgen.WorldgenRandom;
 import net.minecraft.world.level.levelgen.feature.StructureFeature;
 import net.minecraft.world.level.levelgen.feature.configurations.JigsawConfiguration;
@@ -38,13 +27,21 @@ import net.minecraft.world.phys.shapes.VoxelShape;
 import org.apache.commons.lang3.mutable.MutableObject;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
+
+import java.util.*;
+import java.util.function.Predicate;
 
 public class JigsawPlacement {
     static final Logger LOGGER = LogManager.getLogger();
 
     public static Optional<PieceGenerator<JigsawConfiguration>> addPieces(PieceGeneratorSupplier.Context<JigsawConfiguration> context, JigsawPlacement.PieceFactory pieceFactory, BlockPos pos, boolean bl, boolean bl2) {
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
-        worldgenRandom.setLargeFeatureSeed(context.seed(), context.chunkPos().x, context.chunkPos().z);
+        // Matter start
+        WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(
+                context.chunkPos().x, context.chunkPos().z, Globals.Salt.JIGSAW_PLACEMENT, 0
+        );
+        // Matter end
         RegistryAccess registryAccess = context.registryAccess();
         JigsawConfiguration jigsawConfiguration = context.config();
         ChunkGenerator chunkGenerator = context.chunkGenerator();
@@ -199,18 +196,20 @@ public class JigsawPlacement {
                                         if (!boundingBox2.isInside(structureBlockInfox.pos.relative(JigsawBlock.getFrontFacing(structureBlockInfox.state)))) {
                                             return 0;
                                         } else {
-                                            ResourceLocation resourceLocation = new ResourceLocation(structureBlockInfox.nbt.getString("pool"));
-                                            Optional<StructureTemplatePool> optional = this.pools.getOptional(resourceLocation);
-                                            Optional<StructureTemplatePool> optional2 = optional.flatMap((pool) -> {
+                                            // Matter start - compile fix
+                                            ResourceLocation resourceLocation1 = new ResourceLocation(structureBlockInfox.nbt.getString("pool"));
+                                            Optional<StructureTemplatePool> optional1 = this.pools.getOptional(resourceLocation1);
+                                            Optional<StructureTemplatePool> optional1_2 = optional.flatMap((pool) -> {
                                                 return this.pools.getOptional(pool.getFallback());
                                             });
-                                            int i = optional.map((pool) -> {
+                                            int i1 = optional1.map((pool) -> {
                                                 return pool.getMaxSize(this.structureManager);
                                             }).orElse(0);
-                                            int j = optional2.map((pool) -> {
+                                            int j1 = optional1_2.map((pool) -> {
                                                 return pool.getMaxSize(this.structureManager);
                                             }).orElse(0);
-                                            return Math.max(i, j);
+                                            return Math.max(i1, j1);
+                                            // Matter end
                                         }
                                     }).max().orElse(0);
                                 } else {
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/NetherFossilFeature.java b/src/main/java/net/minecraft/world/level/levelgen/structure/NetherFossilFeature.java
index 66dc81f3116b10df660fc37c392ce55bde0e2ffe..59e2ece2367e138aec88b8ac09d5b8dbe5742923 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/NetherFossilFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/NetherFossilFeature.java
@@ -15,6 +15,8 @@ import net.minecraft.world.level.levelgen.WorldgenRandom;
 import net.minecraft.world.level.levelgen.feature.configurations.RangeConfiguration;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGenerator;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGeneratorSupplier;
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
 
 public class NetherFossilFeature extends NoiseAffectingStructureFeature<RangeConfiguration> {
     public NetherFossilFeature(Codec<RangeConfiguration> configCodec) {
@@ -22,8 +24,11 @@ public class NetherFossilFeature extends NoiseAffectingStructureFeature<RangeCon
     }
 
     private static Optional<PieceGenerator<RangeConfiguration>> pieceGeneratorSupplier(PieceGeneratorSupplier.Context<RangeConfiguration> context) {
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
-        worldgenRandom.setLargeFeatureSeed(context.seed(), context.chunkPos().x, context.chunkPos().z);
+        // Matter start
+        WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(
+                context.chunkPos().x, context.chunkPos().z, Globals.Salt.NETHER_FOSSIL_FEATURE, 0
+        );
+        // Matter end
         int i = context.chunkPos().getMinBlockX() + worldgenRandom.nextInt(16);
         int j = context.chunkPos().getMinBlockZ() + worldgenRandom.nextInt(16);
         int k = context.chunkGenerator().getSeaLevel();
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
index f20293426b104ed0c02a931b5ab77f87590f0c18..b33d3e8be3aa95b83a7ce6f8f04d773380637038 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
@@ -205,7 +205,7 @@ public class CraftChunk implements Chunk {
     @Override
     public boolean isSlimeChunk() {
         // 987234911L is deterimined in EntitySlime when seeing if a slime can spawn in a chunk
-        return this.worldServer.paperConfig.allChunksAreSlimeChunks || WorldgenRandom.seedSlimeChunk(this.getX(), this.getZ(), this.getWorld().getSeed(), worldServer.spigotConfig.slimeSeed).nextInt(10) == 0; // Paper
+        return worldServer.getChunk(this.getX(), this.getZ()).isSlimeChunk(); // Matter
     }
 
     @Override
diff --git a/src/main/java/su/plo/matter/Globals.java b/src/main/java/su/plo/matter/Globals.java
new file mode 100644
index 0000000000000000000000000000000000000000..744c6072ee1b6bf87d4d7af6f25650dc81e6a2d1
--- /dev/null
+++ b/src/main/java/su/plo/matter/Globals.java
@@ -0,0 +1,81 @@
+package su.plo.matter;
+
+import com.google.common.collect.Iterables;
+import net.minecraft.server.level.ServerLevel;
+
+import java.math.BigInteger;
+import java.security.SecureRandom;
+
+public class Globals {
+    public static final int WORLD_SEED_LONGS = 16;
+    public static final int WORLD_SEED_BITS = WORLD_SEED_LONGS * 64;
+
+    public static final long[] worldSeed = new long[WORLD_SEED_LONGS];
+    public static final ThreadLocal<Integer> dimension = ThreadLocal.withInitial(() -> 0);
+
+    public enum Salt {
+        UNDEFINED,
+        BASTION_FEATURE,
+        WOODLAND_MANSION_FEATURE,
+        MINESHAFT_FEATURE,
+        BURIED_TREASURE_FEATURE,
+        NETHER_FORTRESS_FEATURE,
+        PILLAGER_OUTPOST_FEATURE,
+        GEODE_FEATURE,
+        NETHER_FOSSIL_FEATURE,
+        OCEAN_MONUMENT_FEATURE,
+        RUINED_PORTAL_FEATURE,
+        POTENTIONAL_FEATURE,
+        GENERATE_FEATURE,
+        JIGSAW_PLACEMENT,
+        STRONGHOLDS,
+        POPULATION,
+        DECORATION,
+        SLIME_CHUNK
+    }
+
+    public static void setupGlobals(ServerLevel world) {
+        long[] seed = world.getServer().getWorldData().worldGenSettings().featureSeed();
+        System.arraycopy(seed, 0, worldSeed, 0, WORLD_SEED_LONGS);
+        int worldIndex = Iterables.indexOf(world.getServer().levelKeys(), it -> it == world.dimension());
+        if (worldIndex == -1) worldIndex = world.getServer().levelKeys().size(); // if we are in world construction it may not have been added to the map yet
+        dimension.set(worldIndex);
+    }
+
+    public static long[] createRandomWorldSeed() {
+        long[] seed = new long[WORLD_SEED_LONGS];
+        SecureRandom rand = new SecureRandom();
+        for (int i = 0; i < WORLD_SEED_LONGS; i++) {
+            seed[i] = rand.nextLong();
+        }
+        return seed;
+    }
+
+    public static long[] parseSeed(String seedStr) throws NumberFormatException {
+        long[] seed = new long[WORLD_SEED_LONGS];
+        BigInteger seedBigInt = new BigInteger(seedStr);
+        if (seedBigInt.signum() < 0) {
+            seedBigInt = seedBigInt.and(BigInteger.ONE.shiftLeft(WORLD_SEED_BITS).subtract(BigInteger.ONE));
+        }
+        for (int i = 0; i < WORLD_SEED_LONGS; i++) {
+            BigInteger[] divRem = seedBigInt.divideAndRemainder(BigInteger.ONE.shiftLeft(64));
+            seed[i] = divRem[1].longValue();
+            seedBigInt = divRem[0];
+        }
+
+        return seed;
+    }
+
+    public static String seedToString(long[] seed) {
+        BigInteger seedBigInt = BigInteger.ZERO;
+        for (int i = WORLD_SEED_LONGS - 1; i >= 0; i--) {
+            BigInteger val = BigInteger.valueOf(seed[i]);
+            if (val.signum() < 0) {
+                val = val.add(BigInteger.ONE.shiftLeft(64));
+            }
+            seedBigInt = seedBigInt.shiftLeft(64).add(val);
+        }
+
+        return seedBigInt.toString();
+    }
+}
diff --git a/src/main/java/su/plo/matter/Hashing.java b/src/main/java/su/plo/matter/Hashing.java
new file mode 100644
index 0000000000000000000000000000000000000000..d18b15ca0b6585f08b30b019c8c17a0f641c8be0
--- /dev/null
+++ b/src/main/java/su/plo/matter/Hashing.java
@@ -0,0 +1,74 @@
+package su.plo.matter;
+
+public class Hashing {
+    // https://en.wikipedia.org/wiki/BLAKE_(hash_function)
+    // https://github.com/bcgit/bc-java/blob/master/core/src/main/java/org/bouncycastle/crypto/digests/Blake2bDigest.java
+
+    private final static long[] blake2b_IV = {
+                    0x6a09e667f3bcc908L, 0xbb67ae8584caa73bL, 0x3c6ef372fe94f82bL,
+                    0xa54ff53a5f1d36f1L, 0x510e527fade682d1L, 0x9b05688c2b3e6c1fL,
+                    0x1f83d9abfb41bd6bL, 0x5be0cd19137e2179L
+            };
+
+    private final static byte[][] blake2b_sigma = {
+                    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
+                    {14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3},
+                    {11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4},
+                    {7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8},
+                    {9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13},
+                    {2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9},
+                    {12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11},
+                    {13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10},
+                    {6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5},
+                    {10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0},
+                    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
+                    {14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3}
+            };
+
+    public static long[] hashWorldSeed(long[] worldSeed) {
+        long[] result = blake2b_IV.clone();
+        result[0] ^= 0x01010040;
+        hash(worldSeed, result, new long[16], 0, false);
+        return result;
+    }
+
+    public static void hash(long[] message, long[] chainValue, long[] internalState, long messageOffset, boolean isFinal) {
+        assert message.length == 16;
+        assert chainValue.length == 8;
+        assert internalState.length == 16;
+
+        System.arraycopy(chainValue, 0, internalState, 0, chainValue.length);
+        System.arraycopy(blake2b_IV, 0, internalState, chainValue.length, 4);
+        internalState[12] = messageOffset ^ blake2b_IV[4];
+        internalState[13] = blake2b_IV[5];
+        if (isFinal) internalState[14] = ~blake2b_IV[6];
+        internalState[15] = blake2b_IV[7];
+
+        for (int round = 0; round < 12; round++) {
+            G(message[blake2b_sigma[round][0]], message[blake2b_sigma[round][1]], 0, 4, 8, 12, internalState);
+            G(message[blake2b_sigma[round][2]], message[blake2b_sigma[round][3]], 1, 5, 9, 13, internalState);
+            G(message[blake2b_sigma[round][4]], message[blake2b_sigma[round][5]], 2, 6, 10, 14, internalState);
+            G(message[blake2b_sigma[round][6]], message[blake2b_sigma[round][7]], 3, 7, 11, 15, internalState);
+            G(message[blake2b_sigma[round][8]], message[blake2b_sigma[round][9]], 0, 5, 10, 15, internalState);
+            G(message[blake2b_sigma[round][10]], message[blake2b_sigma[round][11]], 1, 6, 11, 12, internalState);
+            G(message[blake2b_sigma[round][12]], message[blake2b_sigma[round][13]], 2, 7, 8, 13, internalState);
+            G(message[blake2b_sigma[round][14]], message[blake2b_sigma[round][15]], 3, 4, 9, 14, internalState);
+        }
+
+        for (int i = 0; i < 8; i++) {
+            chainValue[i] ^= internalState[i] ^ internalState[i + 8];
+        }
+    }
+
+    private static void G(long m1, long m2, int posA, int posB, int posC, int posD, long[] internalState)
+    {
+        internalState[posA] = internalState[posA] + internalState[posB] + m1;
+        internalState[posD] = Long.rotateRight(internalState[posD] ^ internalState[posA], 32);
+        internalState[posC] = internalState[posC] + internalState[posD];
+        internalState[posB] = Long.rotateRight(internalState[posB] ^ internalState[posC], 24); // replaces 25 of BLAKE
+        internalState[posA] = internalState[posA] + internalState[posB] + m2;
+        internalState[posD] = Long.rotateRight(internalState[posD] ^ internalState[posA], 16);
+        internalState[posC] = internalState[posC] + internalState[posD];
+        internalState[posB] = Long.rotateRight(internalState[posB] ^ internalState[posC], 63); // replaces 11 of BLAKE
+    }
+}
diff --git a/src/main/java/su/plo/matter/WorldgenCryptoRandom.java b/src/main/java/su/plo/matter/WorldgenCryptoRandom.java
new file mode 100644
index 0000000000000000000000000000000000000000..56a1dccabd29543199fb0eca772fd3ad3ef7104a
--- /dev/null
+++ b/src/main/java/su/plo/matter/WorldgenCryptoRandom.java
@@ -0,0 +1,142 @@
+package su.plo.matter;
+
+import net.minecraft.util.Mth;
+import net.minecraft.world.level.levelgen.LegacyRandomSource;
+import net.minecraft.world.level.levelgen.PositionalRandomFactory;
+import net.minecraft.world.level.levelgen.RandomSource;
+import net.minecraft.world.level.levelgen.WorldgenRandom;
+
+import java.util.Arrays;
+import java.util.Random;
+
+public class WorldgenCryptoRandom extends WorldgenRandom {
+    // hash the world seed to guard against badly chosen world seeds
+    private static final long[] HASHED_ZERO_SEED = Hashing.hashWorldSeed(new long[Globals.WORLD_SEED_LONGS]);
+    private static final ThreadLocal<long[]> LAST_SEEN_WORLD_SEED = ThreadLocal.withInitial(() -> new long[Globals.WORLD_SEED_LONGS]);
+    private static final ThreadLocal<long[]> HASHED_WORLD_SEED = ThreadLocal.withInitial(() -> HASHED_ZERO_SEED);
+
+    private final long[] worldSeed = new long[Globals.WORLD_SEED_LONGS];
+    private final long[] randomBits = new long[8];
+    private int randomBitIndex;
+    private static final int MAX_RANDOM_BIT_INDEX = 64 * 8;
+    private static final int LOG2_MAX_RANDOM_BIT_INDEX = 9;
+    private long counter;
+    private final long[] message = new long[16];
+    private final long[] cachedInternalState = new long[16];
+
+    public WorldgenCryptoRandom(int x, int z, Globals.Salt typeSalt, long salt) {
+        super(new LegacyRandomSource(0L));
+        this.setSecureSeed(x, z, typeSalt, salt);
+    }
+
+    public void setSecureSeed(int x, int z, Globals.Salt typeSalt, long salt) {
+        System.arraycopy(Globals.worldSeed, 0, this.worldSeed, 0, Globals.WORLD_SEED_LONGS);
+        message[0] = ((long) x << 32) | ((long) z & 0xffffffffL);
+        message[1] = ((long) Globals.dimension.get() << 32) | ((long) salt & 0xffffffffL);
+        message[2] = typeSalt.ordinal();
+        message[3] = counter = 0;
+        randomBitIndex = MAX_RANDOM_BIT_INDEX;
+    }
+
+    private long[] getHashedWorldSeed() {
+        if (!Arrays.equals(worldSeed, LAST_SEEN_WORLD_SEED.get())) {
+            HASHED_WORLD_SEED.set(Hashing.hashWorldSeed(worldSeed));
+            System.arraycopy(worldSeed, 0, LAST_SEEN_WORLD_SEED.get(), 0, Globals.WORLD_SEED_LONGS);
+        }
+        return HASHED_WORLD_SEED.get();
+    }
+
+    private void moreRandomBits() {
+        message[3] = counter++;
+        System.arraycopy(getHashedWorldSeed(), 0, randomBits, 0, 8);
+        Hashing.hash(message, randomBits, cachedInternalState, 64, true);
+    }
+
+    private long getBits(int count) {
+        if (randomBitIndex >= MAX_RANDOM_BIT_INDEX) {
+            moreRandomBits();
+            randomBitIndex -= MAX_RANDOM_BIT_INDEX;
+        }
+
+        int alignment = randomBitIndex & 63;
+        if ((randomBitIndex >>> 6) == ((randomBitIndex + count) >>> 6)) {
+            long result = (randomBits[randomBitIndex >>> 6] >>> alignment) & ((1L << count) - 1);
+            randomBitIndex += count;
+            return result;
+        } else {
+            long result = (randomBits[randomBitIndex >>> 6] >>> alignment) & ((1L << (64 - alignment)) - 1);
+            randomBitIndex += count;
+            if (randomBitIndex >= MAX_RANDOM_BIT_INDEX) {
+                moreRandomBits();
+                randomBitIndex -= MAX_RANDOM_BIT_INDEX;
+            }
+            alignment = randomBitIndex & 63;
+            result <<= alignment;
+            result |= (randomBits[randomBitIndex >>> 6] >>> (64 - alignment)) & ((1L << alignment) - 1);
+
+            return result;
+        }
+    }
+
+    @Override
+    public int next(int bits) {
+        return (int) getBits(bits);
+    }
+
+    @Override
+    public void consumeCount(int count) {
+        randomBitIndex += count;
+        if (randomBitIndex >= MAX_RANDOM_BIT_INDEX * 2) {
+            randomBitIndex -= MAX_RANDOM_BIT_INDEX;
+            counter += randomBitIndex >>> LOG2_MAX_RANDOM_BIT_INDEX;
+            randomBitIndex &= MAX_RANDOM_BIT_INDEX - 1;
+            randomBitIndex += MAX_RANDOM_BIT_INDEX;
+        }
+    }
+
+    @Override
+    public int nextInt(int bound) {
+        int bits = Mth.ceillog2(bound);
+        int result;
+        do {
+            result = (int) getBits(bits);
+        } while (result >= bound);
+
+        return result;
+    }
+
+    @Override
+    public long nextLong() {
+        return getBits(64);
+    }
+
+    @Override
+    public double nextDouble() {
+        return getBits(53) * 0x1.0p-53;
+    }
+
+    @Override
+    public long setDecorationSeed(long worldSeed, int blockX, int blockZ) {
+        setSecureSeed(blockX, blockZ, Globals.Salt.POPULATION, 0);
+        return ((long) blockX << 32) | ((long) blockZ & 0xffffffffL);
+    }
+
+    @Override
+    public void setFeatureSeed(long populationSeed, int index, int step) {
+        setSecureSeed((int) (populationSeed >> 32), (int) populationSeed, Globals.Salt.DECORATION, index + 10000L * step);
+    }
+
+    @Override
+    public void setLargeFeatureSeed(long worldSeed, int chunkX, int chunkZ) {
+        super.setLargeFeatureSeed(worldSeed, chunkX, chunkZ);
+    }
+
+    @Override
+    public void setLargeFeatureWithSalt(long worldSeed, int regionX, int regionZ, int salt) {
+        super.setLargeFeatureWithSalt(worldSeed, regionX, regionZ, salt);
+    }
+
+    public static Random seedSlimeChunk(int chunkX, int chunkZ) {
+        return new WorldgenCryptoRandom(chunkX, chunkZ, Globals.Salt.SLIME_CHUNK, 0);
+    }
+}
